//
// nekRS User Defined File
//
#include "udf.hpp"
#include "plugins/tavg.hpp"

static dfloat Re_tau;
static dfloat zLength;

#include "ci.inc"

#ifdef __okl__

#include "turbPipe.oudf"

#endif

void userf(nrs_t *nrs, dfloat time, occa::memory o_U, occa::memory o_FU)
{
  mesh_t *mesh = nrs->meshV;
  dfloat mue, rho;
  platform->options.getArgs("VISCOSITY", mue);
  platform->options.getArgs("DENSITY", rho);
  const dfloat RE_B = rho / mue;
  const dfloat DPDZ = 4 * (2 * Re_tau / RE_B) * (2 * Re_tau / RE_B);

  occa::memory o_FUz = o_FU.slice(2 * nrs->fieldOffset, nrs->fieldOffset);
  platform->linAlg->fill(mesh->Nlocal, DPDZ, o_FUz);
}

void UDF_Setup0(MPI_Comm comm, setupAide &options)
{
  platform->par->extract("casedata", "re_tau", Re_tau);
  platform->par->extract("casedata", "zlength", zLength);

  options.getArgs("CI-MODE", ciMode);
  if (ciMode) {
    ciSetup(comm, options);
  }

  if (platform->options.compareArgs("BUILD ONLY", "FALSE")) {
    double *const nek_cb_scnrs = (double *)nek::ptr("cb_scnrs");
    nek_cb_scnrs[0] = zLength;
  }
}

void UDF_Setup(nrs_t *nrs)
{
if (platform->options.compareArgs("CONSTANT FLOW RATE", "FALSE")) {
    // assign function pointer to drive flow by constant mean pressure gradient
    udf.uEqnSource = &userf;
  }

	std::vector<std::vector<occa::memory>> tavgFields;

	auto o_u    = nrs->o_U.slice(0 * nrs->fieldOffset, nrs->fieldOffset);
	auto o_v    = nrs->o_U.slice(1 * nrs->fieldOffset, nrs->fieldOffset);
	auto o_w    = nrs->o_U.slice(2 * nrs->fieldOffset, nrs->fieldOffset);

	tavgFields.push_back({o_u});
	tavgFields.push_back({o_v});
	tavgFields.push_back({o_w});

	tavg::setup(nrs, tavgFields);

}

void UDF_ExecuteStep(nrs_t *nrs, dfloat time, int tstep)
{
	tavg::run(time);

  if (nrs->lastStep) {
    if (ciMode) {
			auto o_Uavg = tavg::o_avg();
      ciTestErrors(nrs, time, tstep, o_Uavg);

			tavg::outfld();
    }
  }

	if((tstep % 100) ==0){
		nek::ocopyToNek(time, tstep);
		nek::userchk();
	}
}
